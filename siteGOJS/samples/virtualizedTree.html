<!doctype html>
<html>
<head>
  <title>Virtualized Tree</title>
  <!-- Copyright 1998-2013 by Northwoods Software Corporation. -->
  <link href="goSamples.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="go.js"></script>
  <script type="text/javascript" src="goSamples.js"></script>
  <script type="text/javascript" id="code">
    function init() {
      if (window.goSamples) goSamples();  // init for these samples -- you don't need to call this
      var $ = go.GraphObject.make;  // for conciseness in defining templates

      // The Diagram just shows what should be visible in the viewport.
      // Its model does NOT include node data for the whole tree, but only that
      // which is visible in the viewport.  It does not include any Links,
      // because those are all drawn by a single "myOutline" Shape.
      myDiagram =
        $(go.Diagram, "myDiagram",
          {
            allowMove: false,  // don't allow users to do some things
            allowCopy: false,
            allowDelete: false,

            contentAlignment: go.Spot.Center,
            initialDocumentSpot: go.Spot.Center,
            initialViewportSpot: go.Spot.Center,

            // Do manual layout in the layoutTree function below, rather than automatic layout using a
            // TreeLayout, which would require the Nodes and Links to exist first for an accurate layout.
            //layout: $(go.TreeLayout, { nodeSpacing: 4, compaction: go.TreeLayout.CompactionNone }),

            // Define the template for Nodes, used by virtualization.
            nodeTemplate:
              $(go.Node, "Auto",
                { width: 70, height: 20 },
                $(go.Shape, "Rectangle",
                  new go.Binding("fill", "c")),
                $(go.TextBlock,
                  { stroke: "black", margin: 2 },
                  new go.Binding("text", "c")),
                {
                  toolTip:
                    $(go.Adornment, "Auto",
                      $(go.Shape, { fill: "lightyellow" }),
                      $(go.TextBlock, { margin: 3 },
                        new go.Binding("text", "k", function(s) { return "key: " + s; })))
                }
              ),

            // Define the template for Links, not used except for the stroke color.
            linkTemplate:
              $(go.Link, $(go.Shape, { stroke: "black" }))
          });

      // This model includes the entire tree of data
      myTreeModel =
        $(go.TreeModel,
          { // we use single character property names, to save space when rendered as JSON
            nodeKeyProperty: "k",
            nodeParentKeyProperty: "p"
          });
      // Do not set myDiagram.model = myTreeModel -- that would create a zillion Nodes and Links!
      // In the future Diagram may have built-in support for virtualization.
      // For now, we have to implement virtualization ourselves by having the Diagram's model
      // be different than the "real" model.
      myDiagram.model =
        $(go.GraphLinksModel,  // this only holds Nodes, no Links
          { nodeKeyProperty: "k" });  // matching that in myTreeModel

      // This is a status message
      myLoading =
        $(go.Part,
          { selectable: false },
          $(go.TextBlock, "loading...",
            { stroke: "red", font: "20pt sans-serif" }));

      // temporarily add the status indicator
      myDiagram.add(myLoading);

      // allow the myLoading indicator to be shown now,
      // but allow objects added in loadTree to also be considered part of the initial Diagram
      myDiagram.delayInitialization(loadTree);
    }

    // basic tree layout parameters
    var nodeSpacing = 4;
    var layerSpacing = 50;
    var endSegmentLength = 10;
    // this controls whether the tree grows towards the right or downwards:
    var horizontal = true;

    function loadTree() {
      // create a lot of tree data
      var total = 99999;
      var treedata = [];
      for (var i = 0; i < total; i++) {
        var d = {
          k: i,  // this node data's key
          c: go.Brush.randomColor(),  // the node's color
          p: (i > 0 ? Math.floor(Math.random() * i / 2) : undefined)  // the random parent's key
        };
        treedata.push(d);
      }
      myTreeModel.nodeDataArray = treedata;

      // this sets the data.position and data.size on each node data
      layoutTree();

      // for now, we have to implement virtualization ourselves,
      // and only after layoutTree() has finished
      myDiagram.addDiagramListener("ViewportBoundsChanged", onViewportChanged);

      // create a Shape in the shape of the whole tree
      myOutline = createOutline();
      myDiagram.add(myOutline);

      // remove the status indicator
      myDiagram.remove(myLoading);
    }

    // Layout the whole tree just using the model, not any Nodes or Links.
    function layoutTree() {
      var tdata = myTreeModel.nodeDataArray;
      var tdatalen = tdata.length;
      // create an Array of child keys for each parent data
      for (var i = 0; i < tdatalen; i++) {
        var child = tdata[i];
        var parentkey = myTreeModel.getParentKeyForNodeData(child);
        var parent = myTreeModel.findNodeDataForKey(parentkey);
        if (parent) {
          var childarr = parent.children;
          if (childarr) {
            childarr.push(child);
          } else {
            parent.children = [child];
          }
        }
      }

      // layout each tree root
      if (horizontal) {
        var y = 0;
        for (var i = 0; i < tdatalen; i++) {
          var d = tdata[i];
          // is this a root node?
          if (myTreeModel.getParentKeyForNodeData(d) === undefined) {
            sizeNode(d);
            y = walkTreeH(d, 0, y) + d.size.height + nodeSpacing;
          }
        }
        // sort node data by Y position
        tdata.sort(function(a, b) { return a.position.y - b.position.y; });
      } else {  // !horizontal
        var x = 0;
        for (var i = 0; i < tdatalen; i++) {
          var d = tdata[i];
          // is this a root node?
          if (myTreeModel.getParentKeyForNodeData(d) === undefined) {
            sizeNode(d);
            x = walkTreeV(d, x, 0) + d.size.width + nodeSpacing;
          }
        }
        // sort node data by X position
        tdata.sort(function(a, b) { return a.position.x - b.position.x; });
      }
    }

    // Walk subtrees from each root node, positioning as we go.
    function walkTreeH(parent, oldx, oldy) {  // horizontal
      var origy = oldy;
      var newy = oldy;
      var childarr = parent.children;
      if (childarr) {
        var carrlen = childarr.length;
        for (var i = 0; i < carrlen; i++) {
          var child = childarr[i];
          var size = sizeNode(child);
          newy = walkTreeH(child, oldx + size.width + layerSpacing, oldy);
          oldy = newy + size.height + nodeSpacing;
        }
      }
      parent.position = new go.Point(oldx, (origy + newy) / 2);
      return newy;
    }

    function walkTreeV(parent, oldx, oldy) {  // !horizontal
      var origx = oldx;
      var newx = oldx;
      var childarr = parent.children;
      if (childarr) {
        var carrlen = childarr.length;
        for (var i = 0; i < carrlen; i++) {
          var child = childarr[i];
          var size = sizeNode(child);
          newx = walkTreeV(child, oldx, oldy + size.height + layerSpacing);
          oldx = newx + size.width + nodeSpacing;
        }
      }
      parent.position = new go.Point((origx + newx) / 2, oldy);
      return newx;
    }

    // Compute, remember, and return the estimated size of the Node for this data object.
    function sizeNode(data) {
      //!!!???@@@ this needs to be customized to account for your chosen Node template
      var size;
      if (horizontal) {
        size = new go.Size(70 + 2 * endSegmentLength, 20);
      } else {
        size = new go.Size(70, 20 + 2 * endSegmentLength);
      }
      data.size = size;
      return size;
    }

    // Because we cannot afford to create a zillion Parts (Nodes and Links) in either space or time,
    // when the user wants to see all or a large part of the diagram we have to show a simple
    // rendering of the tree.  At small scales, this is visually similar to a diagram of real Parts;
    // at normal scales we create only the Parts that the user might see,
    // which should be a manageable number.
    function createOutline() {
      // create outline of all trees as a single Geometry object
      var geo = new go.Geometry();
      var tdata = myTreeModel.nodeDataArray;
      var tdatalen = tdata.length;
      for (var i = 0; i < tdatalen; i++) {
        var d = tdata[i];
        // is this a root node?
        if (myTreeModel.getParentKeyForNodeData(d) === undefined) {
          // each tree chain has its own PathFigure of lines starting at the root
          var fig;
          if (horizontal) {
            fig = new go.PathFigure(d.position.x, d.position.y + d.size.height / 2, false);
          } else {
            fig = new go.PathFigure(d.position.x + d.size.width / 2, d.position.y, false);
          }
          geo.figures.add(fig);
          walkOutline(d, geo, fig);
        }
      }

      var shape = new go.Shape();
      shape.fill = null;
      shape.stroke = myDiagram.linkTemplate.path.stroke;
      shape.strokeWidth = myDiagram.linkTemplate.path.strokeWidth;
      shape.geometry = geo;
      var outline = new go.Part();
      outline.add(shape);
      outline.selectable = false;
      outline.pickable = false;
      outline.position = new go.Point(0, 0);
      outline.layerName = "Background";
      return outline;
    }

    // Extend the current PathFigure with the first child branch of the subtree starting at PARENT.
    function walkOutline(parent, geo, fig) {
      var endx;
      var endy;
      if (horizontal) {
        endx = parent.position.x + parent.size.width;
        endy = parent.position.y + parent.size.height / 2;
      } else {
        endx = parent.position.x + parent.size.width / 2;
        endy = parent.position.y + parent.size.height;
      }

      var childarr = parent.children;
      if (childarr) {
        // draw the parent's text as a line too, if it has any children
        fig.segments.add(new go.PathSegment(go.PathSegment.Line, endx, endy));

        var carrlen = childarr.length;
        for (var i = 0; i < carrlen; i++) {
          var child = childarr[i];
          if (i === 0) {
            // draw the line to the child
            if (horizontal) {
              fig.segments.add(new go.PathSegment(go.PathSegment.Line, child.position.x, child.position.y + child.size.height / 2));
            } else {
              fig.segments.add(new go.PathSegment(go.PathSegment.Line, child.position.x + child.size.width / 2, child.position.y));
            }
            walkOutline(child, geo, fig);
          } else {
            // start a new line
            var f = new go.PathFigure(endx, endy, false);
            geo.figures.add(f);
            // draw the line to the child
            if (horizontal) {
              f.segments.add(new go.PathSegment(go.PathSegment.Line, child.position.x, child.position.y + child.size.height / 2));
            } else {
              f.segments.add(new go.PathSegment(go.PathSegment.Line, child.position.x + child.size.width / 2, child.position.y));
            }
            walkOutline(child, geo, f);
          }
        }
      } else {
        // just draw the short endSegmentLength
        if (horizontal) {
          fig.segments.add(new go.PathSegment(go.PathSegment.Line, parent.position.x + endSegmentLength, endy));
        } else {
          fig.segments.add(new go.PathSegment(go.PathSegment.Line, endx, parent.position.y + endSegmentLength));
        }
      }
    }

    // If the user is at a relatively large scale, make sure the Parts (Nodes and Links) exist.
    // If we're at a small scale, show only the "Outline" Shape.
    function onViewportChanged(e) {
      if (myDiagram.scale < 0.12) {
        if (myDiagram.nodes.count > 0) {
          if (myOutline !== null) myDiagram.remove(myOutline);
          myDiagram.clear();
          if (myOutline !== null) myDiagram.add(myOutline);
        }
        if (myOutline !== null) {
          // scale up the outline's Shape's strokeWidth so that it doesn't disappear at tiny scales
          myOutline.elt(0).strokeWidth = Math.round(0.20 / myDiagram.scale);
        }
      } else {
        if (myOutline !== null) {
          // reset Outline's Shape to normal strokeWidth
          myOutline.elt(0).strokeWidth = 1;
        }

        // make sure there are Nodes for each node data that is in the viewport
        var viewb = myDiagram.viewportBounds;  // the new viewportBounds
        if (horizontal) {
          var top = viewb.y - 1;
          var bot = viewb.y + viewb.height + 1;

          var tdata = myTreeModel.nodeDataArray;
          var tdatalen = tdata.length;
          // assume the array is sorted by Y position; find the first data.position.y + size.height >= TOP
          var i = 0;
          while (i < tdatalen) {
            var d = tdata[i];
            if (d.position.y + d.size.height >= top) break;
            i++;
          }

          var diamodel = myDiagram.model;
          while (i < tdatalen) {
            var d = tdata[i++];
            if (d.position.y > bot) break;
            if (!diamodel.containsNodeData(d)) {
              diamodel.addNodeData(d);
              var node = myDiagram.findNodeForData(d);
              if (node !== null) {
                var pos = d.position.copy();
                pos.x += endSegmentLength;
                node.position = pos;
              }
            }
          }
        } else {  // !horizontal
          var left = viewb.x - 1;
          var right = viewb.x + viewb.width + 1;

          var tdata = myTreeModel.nodeDataArray;
          var tdatalen = tdata.length;
          // assume the array is sorted by X position; find the first data.position.x + size.width >= LEFT
          var i = 0;
          while (i < tdatalen) {
            var d = tdata[i];
            if (d.position.x + d.size.width >= left) break;
            i++;
          }

          var diamodel = myDiagram.model;
          while (i < tdatalen) {
            var d = tdata[i++];
            if (d.position.x > right) break;
            if (!diamodel.containsNodeData(d)) {
              diamodel.addNodeData(d);
              var node = myDiagram.findNodeForData(d);
              if (node !== null) {
                var pos = d.position.copy();
                pos.y += endSegmentLength;
                node.position = pos;
              }
            }
          }
        }

        if (myRemoveTimer === null) {
          // only remove offscreen nodes after a delay
          myRemoveTimer = setTimeout(removeOffscreen, 2000);
        }
      }

      updateCounts();
    }

    var myRemoveTimer = null;

    function removeOffscreen() {
      myRemoveTimer = null;

      var viewb = myDiagram.viewportBounds;
      if (horizontal) {
        var top = viewb.y - 1;
        var bot = viewb.y + viewb.height + 1;
        var remove = [];
        var it = myDiagram.nodes;
        while (it.next()) {
          var n = it.value;
          var t = n.actualBounds.y;
          var b = t + n.actualBounds.height;
          var d = n.data;
          if (d === null) continue;
          if (t > bot || b < top) remove.push(d);
        }
      } else {  // !horizontal
        var left = viewb.x - 1;
        var right = viewb.x + viewb.width + 1;
        var remove = [];
        var it = myDiagram.nodes;
        while (it.next()) {
          var n = it.value;
          var l = n.actualBounds.x;
          var r = l + n.actualBounds.width;
          var d = n.data;
          if (d === null) continue;
          if (l > right || r < left) remove.push(d);
        }
      }

      var model = myDiagram.model;
      var len = remove.length;
      for (var i = 0; i < len; i++) {
        model.removeNodeData(remove[i]);
      }

      updateCounts();
    }

    function updateCounts() {
      document.getElementById("myMessage1").textContent = myTreeModel.nodeDataArray.length;
      document.getElementById("myMessage2").textContent = myDiagram.nodes.count;
    }
  </script>
</head>
<body onload="init()">
<div id="sample">
  Node data in TreeModel: <span id="myMessage1"></span>.
  Actual Nodes in Diagram: <span id="myMessage2"></span>.
  <div id="myDiagram" style="background-color: white; border: solid 1px blue; width: 100%;height: 800px"></div>
</div>
</body>
</html>
