<!DOCTYPE html>
<html>
<head>
  <title>GoJS Introduction -- Northwoods Software</title>
  <!-- Copyright 1998-2013 by Northwoods Software Corporation. -->
  <link href="goIntro.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="go.js"></script>
  <script type="text/javascript" src="goIntro.js"></script>
</head>
<body onload="goIntro()">
<div id="content">

<h2>Extending GoJS</h2>
<p>
GoJS can be extended in a variety of ways. GoJS supports subclassing Tools and Layouts so that programmers can create their own. Programmers can also override many methods of Commands, Tools, and Layouts.
</p>

<p class="box">
  In addition to our samples, GoJS provides an <strong><a href="../extensions/">extensions gallery</a></strong>, showcasing the creation of custom tools and layouts.
</p>

<p class="box">Overriding the CommandHandler allows you to alter default functionality and create your own key bindings. See the <a href="commands.html">intro page on commands</a> for more.</p>

<h3>Tools</h3>

<p>
  GoJS operates on nodes using several tools, all of which are subclasses of the <a>Tool</a> class, such as <a>ToolManager</a>, <a>PanningTool</a>, <a>ResizingTool</a>, and many more.
</p>
<p>
  Tools can be overridden, and new Tools can be added to the Diagarm's ToolManager. All new Tools must subclass the <a>Tool</a> class.
</p>

<p class="box">See the <a href="tools.html">intro page on tools</a> for more about tools. Some of our samples, such as the <a href="../samples/pipes.html">pipes sample</a>, contain examples of custom tools. More custom tool examples are available in the <a href="../extensions/">extensions gallery</a>.</p>

<h3>Overriding part of a Tool</h3>

<p>
  Oftentimes we can avoid subclassing a Tool or Layout in its entirety and merely override a single method. This is common when we want to make a small change to behavior. Here we'll show how to override the <code>ClickSelectingTool.standardMouseSelect</code> method.
</p>

<p>
  Since we are not creating a new (sub)class, we override the method directly on the Diagarm's ClickSelectingTool, which is referenced through its ToolManager. Typical scaffolding for overriding such a method is as follows:
</p>

<pre data-language="javascript">
  diagram.toolManager.clickSelectingTool.standardMouseSelect = function() {

    // Do some custom operation here
    // ...

    // In cases where you want normal behavior, call the base functionality:
    go.ClickSelectingTool.prototype.standardMouseSelect.call(this);
  }
</pre>

<p>
  As a simple example, we will override the <code>standardMouseSelect</code> to select only Nodes and Links that have a width and height of less than 50 diagram units. This means that we must find the to-be-selected object using <code>diagram.findPartAt</code>, check its bounds, and quit if the bounds are too large. Otherwise, we can call the base functionality to select as we normally might.
</p>

<pre data-language="javascript" id="tool">
  diagram.nodeTemplate =
    $(go.Node, "Auto",
      $(go.Shape, "Rectangle",
        { fill: "white" },
        new go.Binding("fill", "color")),
      $(go.TextBlock,
        { margin: 5 },
        new go.Binding("text", "key"))
    );

  diagram.initialContentAlignment = go.Spot.Center;

  diagram.toolManager.clickSelectingTool.standardMouseSelect = function() {
    var diagram = this.diagram;
    var e = diagram.lastInput;
    // to select containing Group if Part.canSelect() is false
    var curobj = diagram.findPartAt(e.documentPoint, false);
    if (curobj !== null) {
      var bounds = curobj.actualBounds;
      // End the selection process if the bounds are greater than 50 width or height
      if (bounds.width > 50 || bounds.height > 50) {
        // If this was a left click with no modifier, we want to act the same as if
        // we are clicking on the Diagram background, so we clear the selection
        if (e.left && !e.control && !e.shift) {
          diagram.clearSelection();
        }
        // Then return, so that we do not call the base functionality
        return;
      }
    }
    // otherwise, call the base functionality
    go.ClickSelectingTool.prototype.standardMouseSelect.call(this);
  }

  diagram.model = new go.Model([
    { key: "Alpha", color: "lightblue" },
    { key: "Epsilon", color: "thistle" },
    { key: "Psi", color: "lightcoral" },
    { key: "Gamma", color: "lightgreen" }
  ]);
</pre>
<p>
  Running this code, we see that the "Epsilon" and "Gamma" nodes are not selectable, because they are both wider than 50.
</p>
<script type="text/javascript">goCode("tool", 300, 130)</script>


<h3>Subclassing and Creating a new Layout</h3>

<p>
  Layouts can be subclassed to create custom Layouts to be used in Diagrams and groups. Subclassing in GoJS requires a few key steps:
</p>

<ul>
  <li>Create a new class (function), and call the base class constructor.
  <li>Call <a>Diagram.inherit</a> with the new class and the base class.
  <li>Modify the prototype of your derived class to add new functionality.
</ul>

<p>
  To create a new Layout, called <code>CascadeLayout</code>, we would start with the following scaffolding:
</p>

<pre data-language="javascript">
  function CascadeLayout() {
    go.Layout.call(this);
    // new properties go here
  }
  go.Diagram.inherit(CascadeLayout, go.Layout);

  CascadeLayout.prototype.doLayout = function(coll) {
    // layout logic goes here
    // Modify the collection's
  }
</pre>

<p>
Layouts commonly need additional properties that act as layout options. To add a "spacing" property to <code>CascadeLayout</code>, we will use the convention that an underscore member is private, and will set a default value in the constructor:
</p>

<pre data-language="javascript">
  function CascadeLayout() {
    go.Layout.call(this);
    this._spacing = new go.Size(12, 12);
  }
</pre>

<p>
  Then, we use <code>Object.defineProperty</code> to make a "public" getter and setter. Getters and setters allow us to do type checking and have side effects, and this setter makes sure the spacing value is a <code>go.Size</code> object, then invalidates the layout if the value has changed.
</p>

<pre data-language="javascript">
  Object.defineProperty(CascadeLayout.prototype, "spacing", {
    get: function() { return this._spacing; },
    set: function(val) {
      if (!(val instanceof go.Size)) throw new Error("new value for CascadeLayout.spacing must be a Size, not: " + val);
      if (!this._spacing.equals(val)) {
        this._spacing = val;
        this.invalidateLayout();
      }
    }
  });
</pre>

<p>
  Lastly we'll define a <a>Layout.doLayout</a>, being sure to look at the documentation and accomodate all possible input, as doLayout has one argument that can either be a <a>Diagram</a>, or a <a>Group</a>, or an <a>Iterable</a> collection.
</p>
<p>
  All together, we can see the cascade layout in action:
</p>


<pre data-language="javascript" id="example">
  /**
  * @constructor
  * @extends Layout
  * @class
  * This layout arranges nodes in a cascade specified by the spacing property
  */
  function CascadeLayout() {
    go.Layout.call(this);
    this._spacing = new go.Size(12, 12);
  }
  go.Diagram.inherit(CascadeLayout, go.Layout);

  Object.defineProperty(CascadeLayout.prototype, "spacing", {
    get: function() { return this._spacing; },
    set: function(val) {
      if (!(val instanceof go.Size)) throw new Error("new value for CascadeLayout.spacing must be a Size, not: " + val);
      if (!this._spacing.equals(val)) {
        this._spacing = val;
        this.invalidateLayout();
      }
    }
  });

  /**
  * This method positions all Nodes
  * @this {CascadeLayout}
  * @param {Diagram|Group|Iterable} coll the collection of Parts to layout.
  */
  CascadeLayout.prototype.doLayout = function(coll) {
    if (coll === this.diagram) {
      coll = this.diagram.nodes;
    } else if (coll === this.group) {
      coll = this.group.memberParts;
    }

    // Start the layout at the arrangement origin
    var x = this.arrangementOrigin.x;
    var y = this.arrangementOrigin.y;
    var spacing = this.spacing;

    var it = coll.iterator;
    while (it.next()) {
      var node = it.value;
      if (!(node instanceof go.Node)) continue;
      node.move(new go.Point(x, y));
      x += spacing.width;
      y += spacing.height;
    }
  }

  // Regular diagram setup:

  diagram.layout = new CascadeLayout();
  diagram.nodeTemplate =
    $(go.Node, "Auto",
      $(go.Shape, "Rectangle",
        { fill: "white" },
        new go.Binding("fill", "color")),
      $(go.TextBlock,
        { margin: 5 },
        new go.Binding("text", "key"))
    );

  diagram.initialContentAlignment = go.Spot.Center;

  diagram.model = new go.Model([
    { key: "Alpha", color: "lightblue" },
    { key: "Beta", color: "thistle" },
    { key: "Delta", color: "lightcoral" },
    { key: "Gamma", color: "lightgreen" }
  ]);
</pre>
<script type="text/javascript">goCode("example", 300, 200)</script>


</div>
</body>
</html>
